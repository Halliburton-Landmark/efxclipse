/*
 * generated by Xtext 2.9.0
 */
package org.eclipse.fx.ide.css.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.fx.ide.css.cssDsl.AttributeSelector;
import org.eclipse.fx.ide.css.cssDsl.CharsetRule;
import org.eclipse.fx.ide.css.cssDsl.ClassSelector;
import org.eclipse.fx.ide.css.cssDsl.ColorTok;
import org.eclipse.fx.ide.css.cssDsl.CssDeclaration;
import org.eclipse.fx.ide.css.cssDsl.CssDslPackage;
import org.eclipse.fx.ide.css.cssDsl.CssProperty;
import org.eclipse.fx.ide.css.cssDsl.ElementSelector;
import org.eclipse.fx.ide.css.cssDsl.FontFaceRule;
import org.eclipse.fx.ide.css.cssDsl.FuncTok;
import org.eclipse.fx.ide.css.cssDsl.IdSelector;
import org.eclipse.fx.ide.css.cssDsl.IdentifierTok;
import org.eclipse.fx.ide.css.cssDsl.ImportRule;
import org.eclipse.fx.ide.css.cssDsl.KeyframeSelector;
import org.eclipse.fx.ide.css.cssDsl.KeyframesRule;
import org.eclipse.fx.ide.css.cssDsl.Media;
import org.eclipse.fx.ide.css.cssDsl.MediaList;
import org.eclipse.fx.ide.css.cssDsl.MediaRule;
import org.eclipse.fx.ide.css.cssDsl.NumberTok;
import org.eclipse.fx.ide.css.cssDsl.PageRule;
import org.eclipse.fx.ide.css.cssDsl.PseudoClass;
import org.eclipse.fx.ide.css.cssDsl.PseudoClassFunction;
import org.eclipse.fx.ide.css.cssDsl.Ruleset;
import org.eclipse.fx.ide.css.cssDsl.Selector;
import org.eclipse.fx.ide.css.cssDsl.SimpleSelector;
import org.eclipse.fx.ide.css.cssDsl.SimpleSelectorForNegation;
import org.eclipse.fx.ide.css.cssDsl.StringTok;
import org.eclipse.fx.ide.css.cssDsl.Stylesheet;
import org.eclipse.fx.ide.css.cssDsl.SymbolTok;
import org.eclipse.fx.ide.css.cssDsl.URLType;
import org.eclipse.fx.ide.css.cssDsl.UniversalSelector;
import org.eclipse.fx.ide.css.cssDsl.UrlTok;
import org.eclipse.fx.ide.css.cssDsl.WSTok;
import org.eclipse.fx.ide.css.services.CssDslGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CssDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CssDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CssDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CssDslPackage.ATTRIBUTE_SELECTOR:
				sequence_AttributeSelector(context, (AttributeSelector) semanticObject); 
				return; 
			case CssDslPackage.CHARSET_RULE:
				sequence_CharsetRule(context, (CharsetRule) semanticObject); 
				return; 
			case CssDslPackage.CLASS_SELECTOR:
				sequence_ClassSelector(context, (ClassSelector) semanticObject); 
				return; 
			case CssDslPackage.COLOR_TOK:
				sequence_ColorTok(context, (ColorTok) semanticObject); 
				return; 
			case CssDslPackage.CSS_DECLARATION:
				sequence_CssDeclaration(context, (CssDeclaration) semanticObject); 
				return; 
			case CssDslPackage.CSS_PROPERTY:
				sequence_CssProperty(context, (CssProperty) semanticObject); 
				return; 
			case CssDslPackage.ELEMENT_SELECTOR:
				sequence_ElementSelector(context, (ElementSelector) semanticObject); 
				return; 
			case CssDslPackage.FONT_FACE_RULE:
				sequence_FontFaceRule(context, (FontFaceRule) semanticObject); 
				return; 
			case CssDslPackage.FUNC_TOK:
				sequence_IdentifierOrFuncTok(context, (FuncTok) semanticObject); 
				return; 
			case CssDslPackage.ID_SELECTOR:
				sequence_IdSelector(context, (IdSelector) semanticObject); 
				return; 
			case CssDslPackage.IDENTIFIER_TOK:
				sequence_IdentifierOrFuncTok(context, (IdentifierTok) semanticObject); 
				return; 
			case CssDslPackage.IMPORT_RULE:
				sequence_ImportRule(context, (ImportRule) semanticObject); 
				return; 
			case CssDslPackage.KEYFRAME_SELECTOR:
				sequence_KeyframeSelector(context, (KeyframeSelector) semanticObject); 
				return; 
			case CssDslPackage.KEYFRAMES_RULE:
				sequence_KeyframesRule(context, (KeyframesRule) semanticObject); 
				return; 
			case CssDslPackage.MEDIA:
				sequence_Media(context, (Media) semanticObject); 
				return; 
			case CssDslPackage.MEDIA_LIST:
				sequence_MediaList(context, (MediaList) semanticObject); 
				return; 
			case CssDslPackage.MEDIA_RULE:
				sequence_MediaRule(context, (MediaRule) semanticObject); 
				return; 
			case CssDslPackage.NUMBER_TOK:
				sequence_NumberTok(context, (NumberTok) semanticObject); 
				return; 
			case CssDslPackage.PAGE_RULE:
				sequence_PageRule(context, (PageRule) semanticObject); 
				return; 
			case CssDslPackage.PSEUDO_CLASS:
				sequence_PseudoClass(context, (PseudoClass) semanticObject); 
				return; 
			case CssDslPackage.PSEUDO_CLASS_FUNCTION:
				sequence_PseudoClassFunction(context, (PseudoClassFunction) semanticObject); 
				return; 
			case CssDslPackage.RULESET:
				sequence_Ruleset(context, (Ruleset) semanticObject); 
				return; 
			case CssDslPackage.SELECTOR:
				sequence_Selector(context, (Selector) semanticObject); 
				return; 
			case CssDslPackage.SIMPLE_SELECTOR:
				sequence_SimpleSelector(context, (SimpleSelector) semanticObject); 
				return; 
			case CssDslPackage.SIMPLE_SELECTOR_FOR_NEGATION:
				sequence_SimpleSelectorForNegation(context, (SimpleSelectorForNegation) semanticObject); 
				return; 
			case CssDslPackage.STRING_TOK:
				sequence_StringTok(context, (StringTok) semanticObject); 
				return; 
			case CssDslPackage.STYLESHEET:
				sequence_Stylesheet(context, (Stylesheet) semanticObject); 
				return; 
			case CssDslPackage.SYMBOL_TOK:
				sequence_SymbolTok(context, (SymbolTok) semanticObject); 
				return; 
			case CssDslPackage.URL_TYPE:
				if (rule == grammarAccess.getImportRuleRule()) {
					sequence_ImportRule_URLType(context, (URLType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getURLTypeRule()) {
					sequence_URLType(context, (URLType) semanticObject); 
					return; 
				}
				else break;
			case CssDslPackage.UNIVERSAL_SELECTOR:
				sequence_UniversalSelector(context, (UniversalSelector) semanticObject); 
				return; 
			case CssDslPackage.URL_TOK:
				sequence_UrlTok(context, (UrlTok) semanticObject); 
				return; 
			case CssDslPackage.WS_TOK:
				sequence_WSTok(context, (WSTok) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SubSelectorForNegation returns AttributeSelector
	 *     SubSelector returns AttributeSelector
	 *     AttributeSelector returns AttributeSelector
	 *
	 * Constraint:
	 *     (
	 *         name=Identifier 
	 *         (
	 *             (
	 *                 op='^=' | 
	 *                 op='$=' | 
	 *                 op='*=' | 
	 *                 op='=' | 
	 *                 op=INCLUDES | 
	 *                 op=DASHMATCH
	 *             ) 
	 *             (value=Identifier | value=CSSSTRING)
	 *         )?
	 *     )
	 */
	protected void sequence_AttributeSelector(ISerializationContext context, AttributeSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CharsetRule returns CharsetRule
	 *
	 * Constraint:
	 *     charset=CSSSTRING
	 */
	protected void sequence_CharsetRule(ISerializationContext context, CharsetRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.CHARSET_RULE__CHARSET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.CHARSET_RULE__CHARSET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharsetRuleAccess().getCharsetCSSSTRINGTerminalRuleCall_1_0(), semanticObject.getCharset());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubSelectorForNegation returns ClassSelector
	 *     SubSelector returns ClassSelector
	 *     ClassSelector returns ClassSelector
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_ClassSelector(ISerializationContext context, ClassSelector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.CSS_SELECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.CSS_SELECTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassSelectorAccess().getNameIdentifierParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ColorTok returns ColorTok
	 *     CssTok returns ColorTok
	 *
	 * Constraint:
	 *     value=Hex
	 */
	protected void sequence_ColorTok(ISerializationContext context, ColorTok semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.COLOR_TOK__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.COLOR_TOK__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorTokAccess().getValueHexParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssDeclaration returns CssDeclaration
	 *
	 * Constraint:
	 *     (property=CssProperty valueTokens+=CssTok+ important?=IMPORTANT_SYM?)
	 */
	protected void sequence_CssDeclaration(ISerializationContext context, CssDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CssProperty returns CssProperty
	 *
	 * Constraint:
	 *     name=ValidPropertyIdent
	 */
	protected void sequence_CssProperty(ISerializationContext context, CssProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.CSS_PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.CSS_PROPERTY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCssPropertyAccess().getNameValidPropertyIdentParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementSelector returns ElementSelector
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_ElementSelector(ISerializationContext context, ElementSelector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.ELEMENT_SELECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.ELEMENT_SELECTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementSelectorAccess().getNameIdentifierParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FontFaceRule returns FontFaceRule
	 *
	 * Constraint:
	 *     (declarations+=CssDeclaration? declarations+=CssDeclaration*)
	 */
	protected void sequence_FontFaceRule(ISerializationContext context, FontFaceRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubSelectorForNegation returns IdSelector
	 *     SubSelector returns IdSelector
	 *     IdSelector returns IdSelector
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_IdSelector(ISerializationContext context, IdSelector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.CSS_SELECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.CSS_SELECTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdSelectorAccess().getNameIdentifierParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IdentifierOrFuncTok returns FuncTok
	 *     CssTok returns FuncTok
	 *
	 * Constraint:
	 *     (name=IdentifierOrFuncTok_FuncTok_2_0 params+=CssTok+)
	 */
	protected void sequence_IdentifierOrFuncTok(ISerializationContext context, FuncTok semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IdentifierOrFuncTok returns IdentifierTok
	 *     IdentifierOrFuncTok.FuncTok_2_0 returns IdentifierTok
	 *     CssTok returns IdentifierTok
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_IdentifierOrFuncTok(ISerializationContext context, IdentifierTok semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.IDENTIFIER_TOK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.IDENTIFIER_TOK__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifierOrFuncTokAccess().getNameIdentifierParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportRule returns ImportRule
	 *
	 * Constraint:
	 *     value=CSSSTRING
	 */
	protected void sequence_ImportRule(ISerializationContext context, ImportRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.IMPORT_RULE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.IMPORT_RULE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportRuleAccess().getValueCSSSTRINGTerminalRuleCall_1_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportRule returns URLType
	 *
	 * Constraint:
	 *     (url=ValidURL mediaList=MediaList?)
	 */
	protected void sequence_ImportRule_URLType(ISerializationContext context, URLType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyframeSelector returns KeyframeSelector
	 *
	 * Constraint:
	 *     ((type=Identifier | percentage=Num) declarations+=CssDeclaration? declarations+=CssDeclaration*)
	 */
	protected void sequence_KeyframeSelector(ISerializationContext context, KeyframeSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyframesRule returns KeyframesRule
	 *
	 * Constraint:
	 *     (name=Identifier keyframeselectors+=KeyframeSelector? keyframeselectors+=KeyframeSelector*)
	 */
	protected void sequence_KeyframesRule(ISerializationContext context, KeyframesRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MediaList returns MediaList
	 *
	 * Constraint:
	 *     (entry+=Media entry+=Media*)
	 */
	protected void sequence_MediaList(ISerializationContext context, MediaList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MediaRule returns MediaRule
	 *
	 * Constraint:
	 *     (medialist=MediaList rulesets+=Ruleset*)
	 */
	protected void sequence_MediaRule(ISerializationContext context, MediaRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Media returns Media
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_Media(ISerializationContext context, Media semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.MEDIA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.MEDIA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMediaAccess().getNameIdentifierParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumberTok returns NumberTok
	 *     CssTok returns NumberTok
	 *
	 * Constraint:
	 *     val=Num
	 */
	protected void sequence_NumberTok(ISerializationContext context, NumberTok semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.NUMBER_TOK__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.NUMBER_TOK__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberTokAccess().getValNumParserRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PageRule returns PageRule
	 *
	 * Constraint:
	 *     (pseudoPage=PseudoPage? declarations+=CssDeclaration? declarations+=CssDeclaration*)
	 */
	protected void sequence_PageRule(ISerializationContext context, PageRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubSelector returns PseudoClassFunction
	 *     PseudoClassOrFunc returns PseudoClassFunction
	 *     PseudoClassFunction returns PseudoClassFunction
	 *
	 * Constraint:
	 *     ((not?=NotFunctionCall paramSelector=SimpleSelectorForNegation) | (name=Identifier params+=CssTok*))
	 */
	protected void sequence_PseudoClassFunction(ISerializationContext context, PseudoClassFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubSelectorForNegation returns PseudoClass
	 *     SubSelector returns PseudoClass
	 *     PseudoClassOrFunc returns PseudoClass
	 *     PseudoClass returns PseudoClass
	 *
	 * Constraint:
	 *     name=PseudoClassName
	 */
	protected void sequence_PseudoClass(ISerializationContext context, PseudoClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.CSS_SELECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.CSS_SELECTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPseudoClassAccess().getNamePseudoClassNameParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ruleset returns Ruleset
	 *
	 * Constraint:
	 *     (selectors+=Selector selectors+=Selector* (declarations+=CssDeclaration declarations+=CssDeclaration*)?)
	 */
	protected void sequence_Ruleset(ISerializationContext context, Ruleset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns Selector
	 *
	 * Constraint:
	 *     (simpleselectors+=SimpleSelector ((combinator=Combinator selector=Selector) | (combinator=Combinator? selector=Selector))?)
	 */
	protected void sequence_Selector(ISerializationContext context, Selector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleSelectorForNegation returns SimpleSelectorForNegation
	 *
	 * Constraint:
	 *     (((element=ElementSelector | universal=UniversalSelector) subSelectors+=SubSelectorForNegation*) | subSelectors+=SubSelectorForNegation+)
	 */
	protected void sequence_SimpleSelectorForNegation(ISerializationContext context, SimpleSelectorForNegation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleSelector returns SimpleSelector
	 *
	 * Constraint:
	 *     (((element=ElementSelector | universal=UniversalSelector) subSelectors+=SubSelector*) | subSelectors+=SubSelector+)
	 */
	protected void sequence_SimpleSelector(ISerializationContext context, SimpleSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringTok returns StringTok
	 *     CssTok returns StringTok
	 *
	 * Constraint:
	 *     value=CSSSTRING
	 */
	protected void sequence_StringTok(ISerializationContext context, StringTok semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.STRING_TOK__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.STRING_TOK__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTokAccess().getValueCSSSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stylesheet returns Stylesheet
	 *
	 * Constraint:
	 *     (
	 *         (charset=CharsetRule imports+=ImportRule+) | 
	 *         (
	 *             ((charset=CharsetRule imports+=ImportRule+) | imports+=ImportRule+)? 
	 *             (ruleset+=Ruleset | media+=MediaRule | page+=PageRule | font_face+=FontFaceRule | keyframes+=KeyframesRule)+
	 *         ) | 
	 *         imports+=ImportRule+
	 *     )?
	 */
	protected void sequence_Stylesheet(ISerializationContext context, Stylesheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolTok returns SymbolTok
	 *     CssTok returns SymbolTok
	 *
	 * Constraint:
	 *     (symbol=COMMA | symbol=PERCENT)
	 */
	protected void sequence_SymbolTok(ISerializationContext context, SymbolTok semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URLType returns URLType
	 *
	 * Constraint:
	 *     url=ValidURL
	 */
	protected void sequence_URLType(ISerializationContext context, URLType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.URL_TYPE__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.URL_TYPE__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getURLTypeAccess().getUrlValidURLParserRuleCall_1_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UniversalSelector returns UniversalSelector
	 *
	 * Constraint:
	 *     namespace=CssNamespacePrefix?
	 */
	protected void sequence_UniversalSelector(ISerializationContext context, UniversalSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UrlTok returns UrlTok
	 *     CssTok returns UrlTok
	 *
	 * Constraint:
	 *     url=URLType
	 */
	protected void sequence_UrlTok(ISerializationContext context, UrlTok semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CssDslPackage.Literals.URL_TOK__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CssDslPackage.Literals.URL_TOK__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUrlTokAccess().getUrlURLTypeParserRuleCall_1_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WSTok returns WSTok
	 *     CssTok returns WSTok
	 *
	 * Constraint:
	 *     {WSTok}
	 */
	protected void sequence_WSTok(ISerializationContext context, WSTok semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
