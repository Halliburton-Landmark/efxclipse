/**
 * generated by Xtext 2.9.0
 */
package org.eclipse.fx.ide.css.validation;

import com.google.inject.Inject;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.fx.ide.css.cssDsl.CssDeclaration;
import org.eclipse.fx.ide.css.cssDsl.CssDslPackage;
import org.eclipse.fx.ide.css.cssDsl.CssProperty;
import org.eclipse.fx.ide.css.cssDsl.CssTok;
import org.eclipse.fx.ide.css.cssDsl.FontFaceRule;
import org.eclipse.fx.ide.css.cssDsl.IdentifierTok;
import org.eclipse.fx.ide.css.cssDsl.Ruleset;
import org.eclipse.fx.ide.css.cssDsl.Selector;
import org.eclipse.fx.ide.css.cssDsl.StringTok;
import org.eclipse.fx.ide.css.cssDsl.SymbolTok;
import org.eclipse.fx.ide.css.cssDsl.UrlTok;
import org.eclipse.fx.ide.css.cssDsl.WSTok;
import org.eclipse.fx.ide.css.extapi.CssExt;
import org.eclipse.fx.ide.css.extapi.Proposal;
import org.eclipse.fx.ide.css.util.Util;
import org.eclipse.fx.ide.css.validation.AbstractCssDslValidator;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class CssDslValidator extends AbstractCssDslValidator {
  public CssDslValidator() {
    InputOutput.<CssDslValidator>println(this);
  }
  
  @Inject
  public String blub(final XtextResource res) {
    return InputOutput.<String>println(("injected resource: " + res));
  }
  
  @Extension
  private Util util = new Util();
  
  public final static String PROPERTY_UNKNOWN = "property-unknown";
  
  public final static String PROPERTY_UNSUPPORTED_BY_SELECTOR = "property-unsupported-by-selector";
  
  private final static List<String> PREDEFINED_VAR_PROPS = Arrays.<String>asList(
    "-fx-base", "-fx-background", "-fx-control-inner-background", "-fx-control-inner-background-alt", 
    "-fx-dark-text-color", "-fx-mid-text-color", "-fx-light-text-color", "-fx-accent", 
    "-fx-default-button", "-fx-focus-color", "-fx-faint-focus-color", "-fx-color", 
    "CHART_COLOR_1", "CHART_COLOR_2", "CHART_COLOR_3", "CHART_COLOR_4", 
    "CHART_COLOR_5", "CHART_COLOR_6", "CHART_COLOR_7", "CHART_COLOR_8", 
    "CHART_COLOR_1_TRANS_20", "CHART_COLOR_2_TRANS_20", "CHART_COLOR_3_TRANS_20", "CHART_COLOR_4_TRANS_20", 
    "CHART_COLOR_5_TRANS_20", "CHART_COLOR_6_TRANS_20", "CHART_COLOR_7_TRANS_20", "CHART_COLOR_8_TRANS_20", 
    "CHART_COLOR_1_TRANS_70", "CHART_COLOR_2_TRANS_70", "CHART_COLOR_3_TRANS_70", "CHART_COLOR_4_TRANS_70", 
    "CHART_COLOR_5_TRANS_70", "CHART_COLOR_6_TRANS_70", "CHART_COLOR_7_TRANS_70", "CHART_COLOR_8_TRANS_70", 
    "-fx-hover-base", "-fx-pressed-base", "-fx-text-background-color", "-fx-box-border", 
    "-fx-text-box-border", "-fx-shadow-highlight-color", "-fx-outer-border", "-fx-inner-border", 
    "-fx-inner-border-horizontal", "-fx-inner-border-bottomup", "-fx-body-color", "-fx-body-color-bottomup", 
    "-fx-body-color-to-right", "-fx-text-base-color", "-fx-text-inner-color", "-fx-mark-color", 
    "-fx-mark-highlight-color", "-fx-selection-bar", "-fx-selection-bar-non-focused", "-fx-selection-bar-text", 
    "-fx-cell-hover-color", "-fx-cell-focus-inner-border", "-fx-cell-focus-inner-border", "-fx-page-bullet-border", 
    "-fx-page-indicator-hover-border", "-fx-focused-text-base-color", "-fx-focused-mark-color");
  
  @Inject(optional = true)
  private CssExt ext;
  
  public Object doImport(final CssDeclaration d) {
    Object _xblockexpression = null;
    {
      EList<CssTok> _valueTokens = d.getValueTokens();
      final Function1<CssTok, Boolean> _function = (CssTok t) -> {
        return Boolean.valueOf((!(t instanceof WSTok)));
      };
      final Iterable<CssTok> toks = IterableExtensions.<CssTok>filter(_valueTokens, _function);
      Object _xifexpression = null;
      int _size = IterableExtensions.size(toks);
      boolean _equals = (_size == 1);
      if (_equals) {
        Object _xblockexpression_1 = null;
        {
          final CssTok data = ((CssTok[])Conversions.unwrapArray(toks, CssTok.class))[0];
          Object _xifexpression_1 = null;
          if ((data instanceof StringTok)) {
            Object _xtrycatchfinallyexpression = null;
            try {
              Object _xblockexpression_2 = null;
              {
                String _value = ((StringTok)data).getValue();
                URI uri = URI.createURI(_value);
                Resource _eResource = d.eResource();
                URI _uRI = _eResource.getURI();
                URI _resolve = uri.resolve(_uRI);
                uri = _resolve;
                System.err.println(("import " + uri));
                Resource _eResource_1 = d.eResource();
                ResourceSet _resourceSet = _eResource_1.getResourceSet();
                final Resource r = _resourceSet.getResource(uri, true);
                Object _xifexpression_2 = null;
                boolean _and = false;
                boolean _and_1 = false;
                if (!(r instanceof XtextResource)) {
                  _and_1 = false;
                } else {
                  EList<EObject> _contents = r.getContents();
                  int _size_1 = _contents.size();
                  boolean _equals_1 = (_size_1 == 1);
                  _and_1 = _equals_1;
                }
                if (!_and_1) {
                  _and = false;
                } else {
                  EList<EObject> _contents_1 = r.getContents();
                  EObject _get = _contents_1.get(0);
                  Class<? extends EObject> _class = _get.getClass();
                  String _simpleName = _class.getSimpleName();
                  boolean _equals_2 = "CssExtensionImpl".equals(_simpleName);
                  _and = _equals_2;
                }
                if (_and) {
                  _xifexpression_2 = null;
                } else {
                  System.err.println("r is null!");
                  EList<CssTok> _valueTokens_1 = d.getValueTokens();
                  int _indexOf = _valueTokens_1.indexOf(data);
                  this.error("Import not found!", d, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS, _indexOf);
                }
                _xblockexpression_2 = _xifexpression_2;
              }
              _xtrycatchfinallyexpression = _xblockexpression_2;
            } catch (final Throwable _t) {
              if (_t instanceof Throwable) {
                final Throwable e = (Throwable)_t;
                e.printStackTrace();
                EList<CssTok> _valueTokens_1 = d.getValueTokens();
                int _indexOf = _valueTokens_1.indexOf(data);
                this.error("Import not found!", d, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS, _indexOf);
              } else {
                throw Exceptions.sneakyThrow(_t);
              }
            }
            _xifexpression_1 = _xtrycatchfinallyexpression;
          }
          _xblockexpression_1 = _xifexpression_1;
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public boolean isSuppressWarnings(final EObject obj) {
    ICompositeNode _node = NodeModelUtils.getNode(obj);
    String _text = _node.getText();
    return _text.contains("@SuppressWarning");
  }
  
  @Check(CheckType.NORMAL)
  public void checkFontFaceProperties(final FontFaceRule f) {
    if (true) {
      return;
    }
    final long now = System.currentTimeMillis();
    EList<CssDeclaration> _declarations = f.getDeclarations();
    final Consumer<CssDeclaration> _function = (CssDeclaration dec) -> {
      final CssProperty property = dec.getProperty();
      EList<CssTok> _valueTokens = dec.getValueTokens();
      final Function1<CssTok, Boolean> _function_1 = (CssTok t) -> {
        return Boolean.valueOf((!(t instanceof WSTok)));
      };
      final Iterable<CssTok> tokensWithoutWS = IterableExtensions.<CssTok>filter(_valueTokens, _function_1);
      String _name = property.getName();
      boolean _equals = "font-family".equals(_name);
      if (_equals) {
        int _size = IterableExtensions.size(tokensWithoutWS);
        boolean _notEquals = (_size != 1);
        if (_notEquals) {
          this.error("Font family has to define a name", dec, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS);
        } else {
          Object _get = ((Object[])Conversions.unwrapArray(tokensWithoutWS, Object.class))[0];
          boolean _not = (!(_get instanceof IdentifierTok));
          if (_not) {
            final CssTok tok = ((CssTok[])Conversions.unwrapArray(tokensWithoutWS, CssTok.class))[0];
            EList<CssTok> _valueTokens_1 = dec.getValueTokens();
            int _indexOf = _valueTokens_1.indexOf(tok);
            this.error("Invalid font family name", dec, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS, _indexOf);
          }
        }
      } else {
        String _name_1 = property.getName();
        boolean _equals_1 = "src".equals(_name_1);
        if (_equals_1) {
          int _size_1 = IterableExtensions.size(tokensWithoutWS);
          boolean _equals_2 = (_size_1 == 0);
          if (_equals_2) {
            this.error("At least one URL is required", dec, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS);
          } else {
            final Function1<CssTok, Boolean> _function_2 = (CssTok t) -> {
              return Boolean.valueOf((!(t instanceof SymbolTok)));
            };
            Iterable<CssTok> _filter = IterableExtensions.<CssTok>filter(tokensWithoutWS, _function_2);
            final Function1<CssTok, Boolean> _function_3 = (CssTok t) -> {
              return Boolean.valueOf((!(t instanceof UrlTok)));
            };
            Iterable<CssTok> _filter_1 = IterableExtensions.<CssTok>filter(_filter, _function_3);
            final Consumer<CssTok> _function_4 = (CssTok t) -> {
              EList<CssTok> _valueTokens_2 = dec.getValueTokens();
              int _indexOf_1 = _valueTokens_2.indexOf(t);
              this.error("Only url-values are allowed", dec, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS, _indexOf_1);
            };
            _filter_1.forEach(_function_4);
          }
        } else {
          String _name_2 = property.getName();
          boolean _equals_3 = "font-stretch".equals(_name_2);
          if (_equals_3) {
          } else {
            String _name_3 = property.getName();
            boolean _equals_4 = "font-style".equals(_name_3);
            if (_equals_4) {
            } else {
              String _name_4 = property.getName();
              boolean _equals_5 = "font-weight".equals(_name_4);
              if (_equals_5) {
              } else {
                String _name_5 = property.getName();
                boolean _equals_6 = "unicode-range".equals(_name_5);
                if (_equals_6) {
                } else {
                  String _name_6 = property.getName();
                  String _plus = ("Unknown property: \"" + _name_6);
                  String _plus_1 = (_plus + "\"");
                  this.warning(_plus_1, property, CssDslPackage.Literals.CSS_PROPERTY__NAME);
                }
              }
            }
          }
        }
      }
    };
    _declarations.forEach(_function);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("checkFontFaceProperties ");
    long _currentTimeMillis = System.currentTimeMillis();
    long _minus = (_currentTimeMillis - now);
    _builder.append(_minus, "");
    InputOutput.<String>println(_builder.toString());
  }
  
  @Check(CheckType.NORMAL)
  public void checkPropertySupported(final CssProperty p) {
    EObject _eContainer = p.eContainer();
    final CssDeclaration dec = ((CssDeclaration) _eContainer);
    EObject _eContainer_1 = dec.eContainer();
    if ((_eContainer_1 instanceof Ruleset)) {
      EObject _eContainer_2 = dec.eContainer();
      final Ruleset ruleset = ((Ruleset) _eContainer_2);
      EList<Selector> _selectors = ruleset.getSelectors();
      boolean _isPropertyBySelectorSupported = this.ext.isPropertyBySelectorSupported(p, _selectors, p);
      boolean _not = (!_isPropertyBySelectorSupported);
      if (_not) {
        boolean _isSuppressWarnings = this.isSuppressWarnings(p);
        boolean _not_1 = (!_isSuppressWarnings);
        if (_not_1) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("\"");
          CssProperty _property = dec.getProperty();
          String _name = _property.getName();
          _builder.append(_name, "");
          _builder.append("\" is not supported by the given selectors");
          this.warning(_builder.toString(), p, CssDslPackage.Literals.CSS_PROPERTY__NAME, CssDslValidator.PROPERTY_UNSUPPORTED_BY_SELECTOR);
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkPropertyKnown(final CssProperty p) {
    EObject _eContainer = p.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    if ((_eContainer_1 instanceof Ruleset)) {
      boolean _isPropertyKnown = this.ext.isPropertyKnown(p, p);
      boolean _not = (!_isPropertyKnown);
      if (_not) {
        boolean _isSuppressWarnings = this.isSuppressWarnings(p);
        boolean _not_1 = (!_isSuppressWarnings);
        if (_not_1) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Unknown property: \"");
          String _name = p.getName();
          _builder.append(_name, "");
          _builder.append("\"");
          this.warning(_builder.toString(), p, CssDslPackage.Literals.CSS_PROPERTY__NAME, CssDslValidator.PROPERTY_UNKNOWN);
        }
      }
    }
  }
  
  @Check
  public void checkDeclaration(final CssDeclaration dec) {
    if (true) {
      return;
    }
    CssProperty _property = dec.getProperty();
    String _name = _property.getName();
    String _plus = ("checkDeclaration " + _name);
    InputOutput.<String>println(_plus);
    boolean _isMetaDataBlock = this.util.isMetaDataBlock(dec);
    if (_isMetaDataBlock) {
      CssProperty _property_1 = dec.getProperty();
      String _name_1 = _property_1.getName();
      boolean _equals = "import".equals(_name_1);
      if (_equals) {
        this.doImport(dec);
      } else {
        CssProperty _property_2 = dec.getProperty();
        this.warning("Not supported", _property_2, CssDslPackage.Literals.CSS_PROPERTY__NAME);
      }
      return;
    }
    final CssProperty property = dec.getProperty();
    EList<CssTok> _valueTokens = dec.getValueTokens();
    final Function1<CssTok, Boolean> _function = (CssTok t) -> {
      return Boolean.valueOf((!(t instanceof WSTok)));
    };
    final Iterable<CssTok> tokensWithoutWS = IterableExtensions.<CssTok>filter(_valueTokens, _function);
    ICompositeNode _node = NodeModelUtils.getNode(property);
    String _text = _node.getText();
    final boolean suppressWarnings = _text.contains("@SuppressWarning");
    EObject _eContainer = dec.eContainer();
    if ((_eContainer instanceof FontFaceRule)) {
      String _name_2 = property.getName();
      boolean _equals_1 = "font-family".equals(_name_2);
      if (_equals_1) {
        int _size = IterableExtensions.size(tokensWithoutWS);
        boolean _notEquals = (_size != 1);
        if (_notEquals) {
          this.error("Font family has to define a name", dec, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS);
        } else {
          Object _get = ((Object[])Conversions.unwrapArray(tokensWithoutWS, Object.class))[0];
          boolean _not = (!(_get instanceof IdentifierTok));
          if (_not) {
            final CssTok tok = ((CssTok[])Conversions.unwrapArray(tokensWithoutWS, CssTok.class))[0];
            EList<CssTok> _valueTokens_1 = dec.getValueTokens();
            int _indexOf = _valueTokens_1.indexOf(tok);
            this.error("Invalid font family name", dec, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS, _indexOf);
          }
        }
      } else {
        String _name_3 = property.getName();
        boolean _equals_2 = "src".equals(_name_3);
        if (_equals_2) {
          int _size_1 = IterableExtensions.size(tokensWithoutWS);
          boolean _equals_3 = (_size_1 == 0);
          if (_equals_3) {
            this.error("At least one URL is required", dec, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS);
          } else {
            final Function1<CssTok, Boolean> _function_1 = (CssTok t) -> {
              return Boolean.valueOf((!(t instanceof SymbolTok)));
            };
            Iterable<CssTok> _filter = IterableExtensions.<CssTok>filter(tokensWithoutWS, _function_1);
            final Function1<CssTok, Boolean> _function_2 = (CssTok t) -> {
              return Boolean.valueOf((!(t instanceof UrlTok)));
            };
            Iterable<CssTok> _filter_1 = IterableExtensions.<CssTok>filter(_filter, _function_2);
            final Consumer<CssTok> _function_3 = (CssTok t) -> {
              EList<CssTok> _valueTokens_2 = dec.getValueTokens();
              int _indexOf_1 = _valueTokens_2.indexOf(t);
              this.error("Only url-values are allowed", dec, CssDslPackage.Literals.CSS_DECLARATION__VALUE_TOKENS, _indexOf_1);
            };
            _filter_1.forEach(_function_3);
          }
        } else {
          String _name_4 = property.getName();
          boolean _equals_4 = "font-stretch".equals(_name_4);
          if (_equals_4) {
          } else {
            String _name_5 = property.getName();
            boolean _equals_5 = "font-style".equals(_name_5);
            if (_equals_5) {
            } else {
              String _name_6 = property.getName();
              boolean _equals_6 = "font-weight".equals(_name_6);
              if (_equals_6) {
              } else {
                String _name_7 = property.getName();
                boolean _equals_7 = "unicode-range".equals(_name_7);
                if (_equals_7) {
                } else {
                  String _name_8 = property.getName();
                  String _plus_1 = ("Unknown property: \"" + _name_8);
                  String _plus_2 = (_plus_1 + "\"");
                  this.warning(_plus_2, property, CssDslPackage.Literals.CSS_PROPERTY__NAME);
                }
              }
            }
          }
        }
      }
      return;
    }
    final List<Proposal> properties = this.ext.getPropertyProposalsForSelector(dec, null);
    String _name_9 = property.getName();
    boolean _contains = CssDslValidator.PREDEFINED_VAR_PROPS.contains(_name_9);
    if (_contains) {
      return;
    }
    final Function1<Proposal, Boolean> _function_4 = (Proposal p) -> {
      String _proposal = p.getProposal();
      String _name_10 = property.getName();
      return Boolean.valueOf(_proposal.equals(_name_10));
    };
    final boolean known = IterableExtensions.<Proposal>exists(properties, _function_4);
    if ((!known)) {
      if ((!suppressWarnings)) {
        String _name_10 = property.getName();
        String _plus_3 = ("Unknown property: \"" + _name_10);
        String _plus_4 = (_plus_3 + "\"");
        this.warning(_plus_4, property, CssDslPackage.Literals.CSS_PROPERTY__NAME, CssDslValidator.PROPERTY_UNKNOWN);
      }
    } else {
      EObject _eContainer_1 = dec.eContainer();
      final Ruleset rs = ((Ruleset) _eContainer_1);
      final EList<Selector> selectors = rs.getSelectors();
      final List<Proposal> selectorProps = this.ext.getPropertyProposalsForSelector(dec, selectors);
      int _size_2 = selectorProps.size();
      boolean _greaterThan = (_size_2 > 0);
      if (_greaterThan) {
        final Function1<Proposal, Boolean> _function_5 = (Proposal p) -> {
          String _proposal = p.getProposal();
          String _name_11 = property.getName();
          return Boolean.valueOf(_proposal.equals(_name_11));
        };
        final boolean supported = IterableExtensions.<Proposal>exists(selectorProps, _function_5);
        if ((!supported)) {
          if ((!suppressWarnings)) {
            String _name_11 = property.getName();
            String _plus_5 = ("\"" + _name_11);
            String _plus_6 = (_plus_5 + "\" is not supported by the given selectors");
            this.warning(_plus_6, CssDslPackage.Literals.CSS_DECLARATION__PROPERTY, CssDslValidator.PROPERTY_UNSUPPORTED_BY_SELECTOR);
          }
        }
      }
    }
  }
}
